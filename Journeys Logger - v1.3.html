<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Journeys Logger - Vi|llanueva</title>

  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- PapaParse -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    body { background:#f8f9fa; }
    #map { height:460px; border-radius:8px; }
    .metric-box { background:#fff; padding:12px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.06); }
    .chart-container { background:#fff; padding:10px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.06); margin-bottom:16px; max-height:420px; overflow:hidden; }
    h6.chart-title { margin:0 0 6px 0; font-weight:600; font-size:0.95rem; text-align:center; }
    /* ensure inputs don't trigger zoom on iOS */
    input, select, button { font-size:16px !important; }
    /* canvases: allow Chart.js to use canvas height attribute */
    .chart-container canvas { display:block; width:100% !important; }
  </style>
</head>
<body>
  <div class="container-fluid p-4">
    <div class="row mb-3">
      <div class="col text-center">
        <h2 class="text-primary">Journeys Logger</h2>  <!-- *Versión compatible con iOS* -->
        <p class="text-muted">Visualización de telemetría</p>
      </div>
    </div>

    <!-- Controles -->
    <div class="row g-3 mb-3">
      <div class="col-md-4">
        <label class="form-label">📂 Cargar archivo (.log)</label>
        <!-- accept includes text/plain to let iOS show .log in picker -->
        <input id="fileInput" type="file" class="form-control" accept=".log,text/plain,.csv" />
      </div>

      <div class="col-md-3">
        <label class="form-label">📅 Fecha (días con datos)</label>
        <select id="dateSelect" class="form-select">
          <option value="all">Todas las fechas</option>
        </select>
      </div>

      <div class="col-md-3">
        <label class="form-label">🆔 Viaje (trip_id)</label>
        <select id="tripSelect" class="form-select"><option value="">—</option></select>
      </div>

      <div class="col-md-2">
        <label class="form-label">🚗 Transporte</label>
        <select id="modeSelect" class="form-select"><option value="">Todos</option></select>
      </div>
    </div>

    <!-- Mapa -->
    <div class="row mb-3">
      <div class="col-12">
        <div id="map"></div>
      </div>
    </div>

    <!-- Métricas -->
    <div class="row text-center mb-3 g-3">
      <div class="col-md-3"><div class="metric-box"><small class="text-muted">Duración total</small><div id="totalDuration" class="fw-bold">—</div></div></div>
      <div class="col-md-3"><div class="metric-box"><small class="text-muted">Distancia total</small><div id="totalDistance" class="fw-bold">—</div></div></div>
      <div class="col-md-3"><div class="metric-box"><small class="text-muted">Velocidad promedio</small><div id="avgSpeed" class="fw-bold">—</div></div></div>
      <div class="col-md-3"><div class="metric-box"><small class="text-muted">Checkpoints</small><div id="checkpointCount" class="fw-bold">—</div></div></div>
    </div>

    <!-- Gráficas principales -->
    <div class="row">
      <div class="col-md-4">
        <div class="chart-container">
          <h6 class="chart-title">Velocidad promedio por tramo (km/h)</h6>
          <canvas id="speedChart" height="260"></canvas>
        </div>
      </div>
      <div class="col-md-4">
        <div class="chart-container">
          <h6 class="chart-title">Batería (%) vs Evento</h6>
          <canvas id="batteryChart" height="260"></canvas>
        </div>
      </div>
      <div class="col-md-4">
        <div class="chart-container">
          <h6 class="chart-title">Distancia acumulada (km)</h6>
          <canvas id="distanceChart" height="260"></canvas>
        </div>
      </div>
    </div>

    <!-- Gráficas adicionales -->
    <div class="row">
      <div class="col-md-6">
        <div class="chart-container">
          <h6 class="chart-title">Altitud (m) vs Distancia acumulada (km)</h6>
          <canvas id="altitudeChart" height="260"></canvas>
        </div>
      </div>
      <div class="col-md-6">
        <div class="chart-container">
          <h6 class="chart-title">Pendiente (%) por tramo</h6>
          <canvas id="slopeChart" height="260"></canvas>
        </div>
      </div>
    </div>

    <div class="row mb-4">
      <div class="col-12">
        <div class="chart-container">
          <h6 class="chart-title">Correlación: Velocidad (km/h) vs Pendiente (%)</h6>
          <canvas id="speedSlopeChart" height="260"></canvas>
        </div>
      </div>
    </div>

    <!-- Análisis automático -->
    <div class="row">
      <div class="col">
        <div class="metric-box">
          <h5>🧠 Análisis automático</h5>
          <div id="analysisText" class="text-muted">Cargue un archivo para generar el análisis.</div>
        </div>
      </div>
    </div>

  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <script>
  // extract date helper
  function extractDate(value) {
    if (!value && value !== 0) return null;
    if (typeof value === 'string') {
      const m = value.match(/^(\d{4}-\d{2}-\d{2})/);
      if (m) return m[1];
      const d = new Date(value);
      if (!isNaN(d)) return d.toISOString().slice(0,10);
      return null;
    }
    const d = new Date(value);
    if (!isNaN(d)) return d.toISOString().slice(0,10);
    return null;
  }

  let map, markers=[], polyline=null, charts = {};
  let allData = [];

  function initMap() {
    map = L.map('map', { tap:false }).setView([19.43, -99.13], 11);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap' }).addTo(map);
  }
  initMap();

  // File input handling with content detection
  document.getElementById('fileInput').addEventListener('change', (evt) => {
    const file = evt.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      const text = e.target.result;
      // use PapaParse to handle quoted fields etc.
      const res = Papa.parse(text, { header:true, skipEmptyLines:true });
      allData = normalizeRows(res.data);
      afterLoadFixes();
    };
    reader.readAsText(file);
  });

  function normalizeRows(rows) {
    return rows.map(r => {
      const obj = {};
      for (const k of Object.keys(r||{})) obj[k.trim()] = (r[k] !== undefined && r[k] !== null) ? String(r[k]).trim() : r[k];
      return obj;
    }).filter(r => r.trip_id && (r.start_time || r.end_time || (r.lat && r.lon)));
  }

  function afterLoadFixes() {
    buildDateOptions();
    populateTripSelect();
    updateModeSelect();
    updateDashboard();
    // ensure leaflet renders on iOS
    setTimeout(()=>{ try { map.invalidateSize(); } catch(e){} }, 300);
  }

  function buildDateOptions() {
    const dateSelect = document.getElementById('dateSelect');
    const dayMap = new Map();
    for (const row of allData) {
      const day = extractDate(row.start_time);
      if (!day) continue;
      if (!dayMap.has(day)) dayMap.set(day, new Set());
      dayMap.get(day).add(row.trip_id);
    }
    const days = Array.from(dayMap.keys()).sort();
    let options = `<option value="all">Todas las fechas</option>`;
    for (const d of days) {
      const tripsCount = dayMap.get(d).size;
      options += `<option value="${d}">${d} — ${tripsCount} viaje(s)</option>`;
    }
    dateSelect.innerHTML = options;
    dateSelect.onchange = function() {
      populateTripSelect(this.value);
      updateModeSelect();
      updateDashboard();
      setTimeout(()=>{ try { map.invalidateSize(); } catch(e){} }, 200);
    };
  }

  function populateTripSelect(dateValue = 'all') {
    const tripSelect = document.getElementById('tripSelect');
    let tripsSet = new Set();
    if (dateValue === 'all') {
      allData.forEach(r => tripsSet.add(r.trip_id));
    } else {
      allData.forEach(r => {
        const d = extractDate(r.start_time);
        if (d === dateValue) tripsSet.add(r.trip_id);
      });
    }
    const trips = Array.from(tripsSet).sort();
    if (trips.length === 0) {
      tripSelect.innerHTML = `<option value="">— sin viajes —</option>`;
      return;
    }
    tripSelect.innerHTML = trips.map(t => `<option value="${t}">${t}</option>`).join('');
    tripSelect.onchange = () => { updateModeSelect(); updateDashboard(); };
    tripSelect.value = trips[0];
    updateModeSelect();
    updateDashboard();
  }

  function updateModeSelect() {
    const modeSelect = document.getElementById('modeSelect');
    const trip = document.getElementById('tripSelect').value;
    if (!trip) { modeSelect.innerHTML = `<option value="">Todos</option>`; return; }
    const modes = new Set(allData.filter(r=>r.trip_id===trip).map(r=>r.transport_mode).filter(Boolean));
    const modesArr = Array.from(modes);
    modeSelect.innerHTML = `<option value="">Todos</option>` + modesArr.map(m=>`<option value="${m}">${m}</option>`).join('');
    modeSelect.onchange = updateDashboard;
  }

  // NEW: apply filtering rules per trip to include/exclude records based on event_type and note (case-sensitive)
  function applySmartFiltering(rows) {
    // rows: array of records already filtered by date/trip/mode
    // We need to group by trip_id and apply rules per trip
    const byTrip = {};
    rows.forEach(r => {
      const id = r.trip_id || 'unknown';
      if (!byTrip[id]) byTrip[id] = [];
      byTrip[id].push(r);
    });
    const result = [];
    Object.keys(byTrip).forEach(tid => {
      const group = byTrip[tid];
      // check if there exists any Checkpoint in the original group (exact match "Checkpoint")
      const hasAnyCheckpoint = group.some(g => g.event_type === 'Checkpoint');
      group.forEach(g => {
        const et = g.event_type;
        const note = g.note;
        let include = false;
        if (et === 'Departure') include = true;
        else if (et === 'Checkpoint') {
          if (note === 'Tramo') include = true;
          // if note === 'Acumulado' -> include only when no checkpoints exist (handled below)
        } else if (et === 'Arrive') {
          // Arrive should be included for MAP visualization always.
          // For inclusion in calculations we will decide later (outside this function).
          include = true;
        }
        // handle Acumulado: include only if no checkpoints exist in trip
        if (!include && note === 'Acumulado' && !hasAnyCheckpoint) include = true;
        if (include) result.push(g);
      });
    });
    // preserve original ordering by seq_index/date where possible
    result.sort((a,b) => {
      const ai = Number(a.seq_index), bi = Number(b.seq_index);
      if (!isNaN(ai) && !isNaN(bi)) return ai - bi;
      const ad = new Date(a.start_time || a.end_time || 0);
      const bd = new Date(b.start_time || b.end_time || 0);
      return ad - bd;
    });
    return result;
  }

  function updateDashboard() {
    const dateValue = document.getElementById('dateSelect').value;
    const trip = document.getElementById('tripSelect').value;
    const mode = document.getElementById('modeSelect').value;

    let filteredOrig = allData.slice();
    if (dateValue && dateValue !== 'all') filteredOrig = filteredOrig.filter(r => extractDate(r.start_time) === dateValue);
    if (trip) filteredOrig = filteredOrig.filter(r => r.trip_id === trip);
    if (mode) filteredOrig = filteredOrig.filter(r => r.transport_mode === mode);

    // Determine per-trip presence of any checkpoint (from original filtered set)
    const tripHasAnyCheckpoint = {};
    filteredOrig.forEach(r => {
      const id = r.trip_id || 'unknown';
      if (!tripHasAnyCheckpoint[id]) tripHasAnyCheckpoint[id] = false;
      if (r.event_type === 'Checkpoint') tripHasAnyCheckpoint[id] = true;
    });

    // Apply smart filtering rules per trip (this returns rows to USE for MAP and general inclusion)
    const filteredForMap = applySmartFiltering(filteredOrig);

    // For CALCULATIONS we must exclude Arrive if the trip has any Checkpoint.
    // But if the trip has NO checkpoints (only Departure+Arrive or Acumulado), Arrive should be included.
    const calcRows = filteredForMap.filter(r => {
      if (r.event_type === 'Arrive') {
        const id = r.trip_id || 'unknown';
        return !tripHasAnyCheckpoint[id]; // include Arrive in calculations only if no checkpoints exist in that trip
      }
      return true;
    });

    // If no rows to visualize/calculations
    if (!filteredForMap.length) {
      clearMapAndCharts();
      document.getElementById('analysisText').innerText = 'No hay datos para la combinación seleccionada.';
      document.getElementById('totalDistance').innerText = '—';
      document.getElementById('totalDuration').innerText = '—';
      document.getElementById('avgSpeed').innerText = '—';
      document.getElementById('checkpointCount').innerText = '0';
      return;
    }

    // Map: use filteredForMap (includes Arrive as marker always)
    markers.forEach(m=>map.removeLayer(m)); markers = [];
    if (polyline) { map.removeLayer(polyline); polyline = null; }

    const latlngs = filteredForMap.map(r => [Number(r.lat), Number(r.lon)]).filter(p => !isNaN(p[0]) && !isNaN(p[1]));
    if (latlngs.length) {
      polyline = L.polyline(latlngs, { color: '#2b6cb0', weight: 3 }).addTo(map);
      setTimeout(()=>{ try { map.fitBounds(polyline.getBounds(), {padding:[30,30]}); map.invalidateSize(); } catch(e){} }, 150);
    }

    filteredForMap.forEach(r => {
      const ev = (r.event_type || '').toString();
      let color = '#6c757d';
      if (ev === 'Departure') color = '#17a2b8';
      if (ev === 'Checkpoint') color = '#ffb020';
      if (ev === 'Arrive') color = '#28a745';
      if (!r.lat || !r.lon) return;

      let m;
      if (ev === 'Departure') {
        m = L.marker([Number(r.lat), Number(r.lon)], {
          icon: L.divIcon({
            className: 'custom-emoji-marker',
            html: '<span style="font-size:20px;">📍</span>',
            iconSize: [20, 20],
            iconAnchor: [10, 20]
          })
        }).addTo(map);
      } else if (ev === 'Arrive') {
        const offsetLat = Number(r.lat) + 0.0000;
        m = L.marker([offsetLat, Number(r.lon)], {
          icon: L.divIcon({
            className: 'custom-emoji-marker',
            html: '<span style="font-size:20px;">🏁</span>',
            iconSize: [20, 20],
            iconAnchor: [10, 20]
          })
        }).addTo(map);
      } else {
        m = L.circleMarker([Number(r.lat), Number(r.lon)], { radius:6, fillColor: color, color:'#fff', weight:1.2 }).addTo(map);
      }

      const popup = `<b>${r.event_type}</b><br/>trip: ${r.trip_id}<br/>seq: ${r.seq_index || '-'}<br/>${r.note || ''}<br/>bat: ${r.battery_percent||'-'}%`;
      m.bindPopup(popup);
      markers.push(m);
    });

    // Metrics: use calcRows (Arrive excluded if trip has checkpoints)
    const totalDistance = calcRows.reduce((s,r)=> s + (Number(r.distance_km) || 0), 0);
    let durationMin = 0;
    const first = calcRows[0], last = calcRows[calcRows.length-1];
    if (first && last && first.start_time && last.end_time) {
      const d = (new Date(last.end_time) - new Date(first.start_time))/60000;
      if (!isNaN(d)) durationMin = d;
    }
    if (!durationMin) durationMin = calcRows.reduce((s,r)=> s + (Number(r.duration_m) || 0), 0);

    const avgSpeed = (durationMin > 0) ? (totalDistance / (durationMin/60)) : (calcRows.reduce((s,r)=> s + (Number(r.speed_kmh)||0),0)/Math.max(1,calcRows.length));

    document.getElementById('totalDistance').innerText = `${totalDistance.toFixed(2)} km`;
    document.getElementById('totalDuration').innerText = `${Math.floor(durationMin/60)}h ${Math.round(durationMin%60)}m`;
    document.getElementById('avgSpeed').innerText = `${isNaN(avgSpeed) ? '—' : avgSpeed.toFixed(1) + ' km/h'}`;
    // checkpoint count based on filteredForMap inclusion (only Tramo were included)
    document.getElementById('checkpointCount').innerText = filteredForMap.filter(r=> (r.event_type||'') === 'Checkpoint').length;

    // Charts data based on calcRows
    const labels = calcRows.map((r,i) => `#${r.seq_index||i}`);
    const speeds = calcRows.map(r => Number(r.speed_kmh) || null);
    const battery = calcRows.map(r => (r.battery_percent !== undefined ? Number(r.battery_percent) : null));
    let cum = 0;
    const distPoints = calcRows.map(r => { let d = Number(r.distance_km); if (isNaN(d)) d = 0; cum += d; return Number(cum.toFixed(3)); });
    const altitude = calcRows.map(r => Number(r.altitude_m) || null);
    const slope = calcRows.map(r => Number(r.slope_percent) || null);

    renderLineChart('speedChart', labels, speeds, 'Velocidad (km/h)');
    renderLineChart('batteryChart', labels, battery, 'Batería (%)', {yMax:100, borderColor:'#dc2626'});
    renderLineChart('distanceChart', labels, distPoints, 'Distancia acumulada (km)');
    renderLineChart('altitudeChart', labels, altitude, 'Altitud (m)');
    renderLineChart('slopeChart', labels, slope, 'Pendiente (%)');
    renderScatter('speedSlopeChart', slope, speeds, 'Velocidad vs Pendiente');

    // Analysis
    const b0 = battery.find(x=>x!=null), bEnd = battery.slice().reverse().find(x=>x!=null);
    let battNote = 'No hay datos de batería.';
    if (b0 !== undefined && bEnd !== undefined) battNote = `Batería: ${b0}% → ${bEnd}% (${(bEnd - b0 >=0 ? '+' : '') + (bEnd - b0)} pts).`;
    const altVals = altitude.filter(x=>x!=null);
    const minAlt = altVals.length ? Math.min(...altVals) : null;
    const maxAlt = altVals.length ? Math.max(...altVals) : null;
    let altNote = (minAlt!==null) ? `Altitud: ${minAlt} m → ${maxAlt} m.` : 'No hay datos de altitud.';
    document.getElementById('analysisText').innerText = `Viaje ${trip || '(varios)'} — ${totalDistance.toFixed(2)} km en ${Math.round(durationMin)} min. ${battNote} ${altNote}`;

    setTimeout(()=>{ try { map.invalidateSize(); } catch(e){} }, 300);
  }

  function renderLineChart(id, labels, data, label, opts={}) {
    const ctx = document.getElementById(id);
    if (charts[id]) {
      try { charts[id].destroy(); } catch(e) {}
      charts[id] = null;
    }
    const borderColor = opts.borderColor || '#1976d2';
    charts[id] = new Chart(ctx, {
      type: 'line',
      data: { labels, datasets: [{ label, data, fill:false, tension:0.25, borderColor: borderColor, pointRadius:3 }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display:false } },
        scales: { y: { beginAtZero:true, max: opts.yMax || undefined } }
      }
    });
  }

  function renderScatter(id, xData, yData, label) {
    const ctx = document.getElementById(id);
    if (charts[id]) {
      try { charts[id].destroy(); } catch(e) {}
      charts[id] = null;
    }
    const points = xData.map((x,i)=> ({x: (x===null? null : x), y: (yData[i]===null? null : yData[i])})).filter(p => p.x!==null && p.y!==null);
    charts[id] = new Chart(ctx, {
      type: 'scatter',
      data: { datasets: [{ label, data: points, backgroundColor:'#9c27b0' }] },
      options: { responsive:true, maintainAspectRatio:false, scales: { x:{ title:{display:true, text:'Pendiente (%)'} }, y:{ title:{display:true, text:'Velocidad (km/h)'} } } }
    });
  }

  function clearMapAndCharts() {
    markers.forEach(m=>map.removeLayer(m)); markers = [];
    if (polyline) { map.removeLayer(polyline); polyline = null; }
    for (const k in charts) { if (charts[k]) { try { charts[k].destroy(); } catch(e){}; charts[k] = null; } }
  }

  </script>
</body>
</html>
